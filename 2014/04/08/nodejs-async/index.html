
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>javascript 异步编程总结 | blog of purplebamboo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="purplebamboo">
    
    <meta name="description" content="javascript一直被人诟病的就是异步操作，总是带来很多的callback形成所谓的恶魔金字塔。传统意义上的前端浏览器开发遇到的还不多，在后端nodejs开发时，这种情况经常遇到。如何处理这种异步操作，已经成为了一个合格的前端的必修课。下面整理一下最近了解过的各种异步编程知识。
一个生活例子
假">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
	<div style="position: fixed;top: 0;left: 0;background: rgba(0,0,0,0.5);width: 100%;height: 30px;line-height: 30px;text-align: center;color: #f40;">此博客不再维护，博客已迁移至 <a style="color:#f40;" href="https://github.com/purplebamboo/blog/issues" target="_blank"> https://github.com/purplebamboo/blog/issues </a></div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="blog of purplebamboo" title="blog of purplebamboo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="blog of purplebamboo">blog of purplebamboo</a></h1>
				<h2 class="blog-motto">dota诚可贵，coding价更高，若为女朋友，二者皆可抛。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:purplebamboo.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/nodejs-async/" title="javascript 异步编程总结" itemprop="url">javascript 异步编程总结</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://purplebamboo.github.com" title="purplebamboo">purplebamboo</a>
    </p>
  <p class="article-time">
    <time datetime="2014-04-08T05:32:56.000Z" itemprop="datePublished">4月 8 2014</time>
    更新日期:<time datetime="2014-12-21T10:36:57.000Z" itemprop="dateModified">12月 21 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个生活例子"><span class="toc-number">1.</span> <span class="toc-text">一个生活例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件发布订阅方式"><span class="toc-number">2.</span> <span class="toc-text">事件发布订阅方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise_和_Defferred"><span class="toc-number">3.</span> <span class="toc-text">Promise 和 Defferred</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尾触发机制"><span class="toc-number">4.</span> <span class="toc-text">尾触发机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wind-js"><span class="toc-number">5.</span> <span class="toc-text">wind.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generator_and_co"><span class="toc-number">6.</span> <span class="toc-text">generator and co</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">7.</span> <span class="toc-text">结语</span></a></li></ol>
		</div>
		
		<p>javascript一直被人诟病的就是异步操作，总是带来很多的callback形成所谓的恶魔金字塔。传统意义上的前端浏览器开发遇到的还不多，<br>在后端nodejs开发时，这种情况经常遇到。如何处理这种异步操作，已经成为了一个合格的前端的必修课。下面整理一下最近了解过的各种异步编程知识。</p>
<h2 id="一个生活例子">一个生活例子</h2>
<p>假设还有1秒钟就到下班的点了，胖子虽然急着回家，但是也只能等着。</p>
<p>两件事：<br>第一件，下班。我们用个函数模拟下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">offWork</span><span class="params">(callback)</span>{</span>
    console.log(<span class="string">"上班ing。。。"</span>)
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"下班了。。。"</span>)
        callback();
    },<span class="number">1000</span>);
}
</pre></td></tr></table></figure>

<p>第二件，回家。模拟如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">backHome</span><span class="params">(callback)</span>{</span>
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"到家了！！！"</span>)
        callback();
    },<span class="number">1000</span>);
    console.log(<span class="string">"回家ing。。。"</span>)
}
</pre></td></tr></table></figure>

<p>下班是1秒之后才发生的事情。所以 我们是不能这么干的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="function"><span class="title">offWork</span><span class="params">()</span>
<span class="title">backHome</span><span class="params">()</span></span>
</pre></td></tr></table></figure>

<p>还没下班，胖子就回家了。这样就等着被骂吧。</p>
<p>所以我们只能乖乖的投降，慢慢的等待。于是就有了下面这样的写法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>offWork(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    backHome()
})
</pre></td></tr></table></figure>

<p>恩看起来还不错。。是吧</p>
<p>但是，回家后还要吃饭，而且回家也是需要时间的。。吃饭后还要看睡觉，吃饭也是需要时间的，于是在javascript里面，我们就变成了这样写。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>offWork(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    backHome(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        eatFood(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            sleep(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
                。。。。
            })
        })
    })

})
</pre></td></tr></table></figure>

<p>这就是恶魔金字塔问题了。</p>
<p>所以callback虽然可以简单的解决异步调用问题。但是异步一多，就会让人无法忍受，我们需要一些新的方式。下面就介绍几种目前比较火的方式。</p>
<h2 id="事件发布订阅方式">事件发布订阅方式</h2>
<p>这种方式使用一种观察者的设计模式</p>
<blockquote>
<p>不知道什么是观察者模式的可以先去补补23种设计模式。建议通过java这些比较成熟的语言来了解这些模式。javascript虽然也可以实现，但个人觉得不适合初学者很好的理解。</p>
</blockquote>
<p>所谓的观察者模式，是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</p>
<p>说白了，就是我们平时使用的事件机制。</p>
<p>为了更好的理解。首先我们实现一个最简单的事件监听程序。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
	<span class="keyword">this</span>._callbacks = {};
	<span class="keyword">this</span>._fired = {};
};

Observer.prototype.addListener = <span class="function"><span class="keyword">function</span><span class="params">(eventname, callback)</span> {</span>
     <span class="keyword">this</span>._callbacks[eventname] = <span class="keyword">this</span>._callbacks[eventname] || [];
     <span class="keyword">this</span>._callbacks[eventname].push(callback);
     <span class="keyword">return</span> <span class="keyword">this</span>;
}

Observer.prototype.removeListener = <span class="function"><span class="keyword">function</span><span class="params">(eventname,callback)</span>{</span>
	<span class="keyword">var</span> cbs = <span class="keyword">this</span>._callbacks,cbList,cblength;
	<span class="keyword">if</span>(!eventname) <span class="keyword">return</span> <span class="keyword">this</span>;
	<span class="keyword">if</span>(!callback){
        cbs[eventname] = [];
	}<span class="keyword">else</span>{
        cbList = cbs[eventname];
        <span class="keyword">if</span> (!cbList) <span class="keyword">return</span> <span class="keyword">this</span>;
        cblength = cbList.length;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cblength; i++) {
        	<span class="keyword">if</span> (callback === cbList[i]) {
        		cbList.splice(i, <span class="number">1</span>);
        		<span class="keyword">break</span>;
        	}
        }
	}
}

Observer.prototype.fire = <span class="function"><span class="keyword">function</span><span class="params">(eventname,data)</span>{</span>
    <span class="keyword">var</span> cbs = <span class="keyword">this</span>._callbacks,cbList,i,l;
    <span class="keyword">if</span>(!cbs[eventname]) <span class="keyword">return</span> <span class="keyword">this</span>;
    cbList = cbs[eventname];
    <span class="keyword">if</span> (cbList) {
    	<span class="keyword">for</span> (i = <span class="number">0</span>, l = cbList.length; i &lt; l; i++) {
    		cbList[i].apply(<span class="keyword">this</span>,<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));

    	}

    }


}
</pre></td></tr></table></figure>

<p>可以看到原来很简单，将事件对应的处理函数储存起来，fire的时候拿出来调用。这样一个简单的事件监听就弄好了，当然这只是个非常简陋的原型。= =就不要在意太多细节了。</p>
<p>现在我们可以这么写了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> observer = <span class="keyword">new</span> Observer();


observer.addListener(<span class="string">'backHomed'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">//eatFood(function(){</span>
        <span class="comment">//.....</span>
    <span class="comment">//});</span>
})

observer.addListener(<span class="string">'offworked'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    backHome(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        observer.fired(<span class="string">'backHomed'</span>);
    });
})

offWork(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    observer.fire(<span class="string">'offworked'</span>);
})
</pre></td></tr></table></figure>

<p>可以看到，事件监听极大的减少了各个任务之间的耦合。有效的解决了恶魔金字塔的问题。but，看着还是好刺眼啊。代码组织起来还是很吃力。</p>
<p>我们需要做点什么，改造下任务函数再加点扩展。扩展之后我们可以这么调用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> observer = <span class="keyword">new</span> Observer();
observer.queue([offWork,backHome],<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
    console.log(<span class="string">"eating"</span>);
});
</pre></td></tr></table></figure>

<p>我们看下queue的扩展代码:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>Observer.prototype.queue = <span class="function"><span class="keyword">function</span><span class="params">(queue,callback)</span>{</span>
    <span class="keyword">var</span> eventName = <span class="string">''</span>;
    <span class="keyword">var</span> index= <span class="number">0</span>;
    <span class="keyword">var</span> data = [];
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> task = <span class="literal">null</span>;

    <span class="keyword">var</span> _getFireCb = <span class="function"><span class="keyword">function</span><span class="params">(ename)</span>{</span>

        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(val)</span>{</span>
            val = val || <span class="literal">null</span>;
            self.fire(ename,val);
        }
    }
    <span class="keyword">var</span> _next = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">if</span>((task = queue.shift()) != <span class="literal">undefined</span>){
            eventName = <span class="string">'queueEvent'</span> + index++;
            self[<span class="string">"addListener"</span>](eventName, <span class="function"><span class="keyword">function</span><span class="params">(val)</span>{</span>
                data.push(val);
                _next();
            })
            task.call(<span class="keyword">this</span>,_getFireCb(eventName));
        }<span class="keyword">else</span>{
            callback.apply(<span class="literal">null</span>, [data]);
        }
    }
    _next();

}
</pre></td></tr></table></figure>

<p>实现思路是这样的，从队列里挨个的取出task，增加事件监听，自动生成callback注入，这样task执行完后会fire一下。监听的回调函数里再调用_next拿出下个task重复流程。</p>
<p>有的时候我们对于顺序并不看重，比如对于吃饭这个问题，a,b,c吃饭，只要三个人都吃完了就可以去结账了。他们谁先吃完我们都不用管，如果按照上面的思路，就得a先吃，a吃完b吃，b吃完再c吃。白白浪费很多时间，我们需要发挥异步的优势，采用并行的执行方式。所以有了下面的when扩展。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">aEat</span><span class="params">(callback)</span>{</span>

    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"a吃完了。。。"</span>)
        callback();
    },<span class="number">1000</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">bEat</span><span class="params">(callback)</span>{</span>
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"b吃完了。。。"</span>)
        callback();
    },<span class="number">1000</span>);

}
<span class="keyword">var</span> observer = <span class="keyword">new</span> Observer();
observer.when(<span class="string">"a-eat-ok"</span>,<span class="string">"b-eat-ok"</span>,<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
    console.log(<span class="string">"结账"</span>);
});

aEat(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    observer.fired(<span class="string">'a-eat-ok'</span>);
})

bEat(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    observer.fired(<span class="string">'b-eat-ok'</span>);
});
</pre></td></tr></table></figure>

<p>我们看下when的实现方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre>
Observer.prototype.when = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
	<span class="keyword">var</span> events,callback,i,l,<span class="keyword">self</span>,argsLength;
    argsLength = arguments.length;
	events = <span class="keyword">Array</span>.prototype.slice.apply(arguments, [<span class="number">0</span>, argsLength - <span class="number">1</span>]);
    callback = arguments[argsLength - <span class="number">1</span>];
    <span class="keyword">if</span> (typeof callback !== <span class="string">"function"</span>) {
      <span class="keyword">return</span> this;
    }
    <span class="keyword">self</span> = this;
    l = events.length;
    <span class="keyword">var</span> _isOk = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    	<span class="keyword">var</span> data = [];
    	<span class="keyword">var</span> isok = <span class="keyword">true</span>;
    	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) {

            <span class="keyword">if</span>(!<span class="keyword">self</span>._fired.hasOwnProperty(events[i])||!<span class="keyword">self</span>._fired[events[i]].hasOwnProperty(<span class="string">"data"</span>)){
                isok = <span class="keyword">false</span>;
                <span class="keyword">break</span>;
            }
            <span class="keyword">var</span> d = <span class="keyword">self</span>._fired[events[i]].data;
    	    data.push(d);
    	}
    	<span class="keyword">if</span>(isok) callback.apply(<span class="keyword">null</span>, [data]);

    }
    <span class="keyword">var</span> _bind =<span class="function"><span class="keyword">function</span><span class="params">(key)</span>{</span>
    	<span class="keyword">self</span>[<span class="string">"addListener"</span>](key, <span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
            <span class="keyword">self</span>._fired[key] = <span class="keyword">self</span>._fired[key] || {};
            <span class="keyword">self</span>._fired[key].data = data;
            _isOk();
    	})
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l;i++){
       _bind(events[i]);
    }

    <span class="keyword">return</span> this;
}
</pre></td></tr></table></figure>

<p>这段代码。其实不难，也是基于上面的事件基础上实现的。实现方法主要是对所有的事件进行监听。每个事件触发后，都会去检查其他事件是否都已经触发完毕了。如果发现都触发了就调用回调函数。当然这个扩展只适合不讲究顺序的并行执行情况。</p>
<blockquote>
<p>上面的例子大部分参考eventproxy的实现，有兴趣的人可以去了解一下。</p>
</blockquote>
<h2 id="Promise_和_Defferred">Promise 和 Defferred</h2>
<p>Promise是一种规范，Promise都拥有一个叫做then的唯一接口，当Promise失败或成功时，它就会进行回调。它代表了一种可能会长时间运行而且不一定必须完成的操作结果。这种模式不会阻塞和等待长时间的操作完成，而是返回一个代表了承诺的（promised）结果的对象。Defferred就是之后来处理回调的对象。二者紧密不可分割。</p>
<p>如果有了promise，我们可以这么调用上面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span></span>{
    var d = new Deffered();

    offWork(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        d.resolve(<span class="string">'done----offWork'</span>);
    })
    <span class="keyword">return</span> d.promise;

}

start().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    var d = new Deffered();
    backHome(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        d.resolve(<span class="string">'done----backhome'</span>);
    })
    <span class="keyword">return</span> d.promise;
}).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    /** var d = new Deffered();
    eatFood(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
       	d.resolve(<span class="string">'done----eatFood'</span>);
    })
    <span class="keyword">return</span> d.promise;**/
    console.log(<span class="string">'eating'</span>);
})
</pre></td></tr></table></figure>

<p>看起来清晰多了吧。通过then可以很方便的按顺序链式调用。</p>
<p>下面我们来实现一个基础的promise:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre>
<span class="keyword">var</span> Deffered = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
	<span class="keyword">this</span>.promise = <span class="keyword">new</span> Promise(<span class="keyword">this</span>);
	<span class="keyword">this</span>.lastReturnValue = <span class="string">''</span>;
}


Deffered.prototype.resolve = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span>{</span>
	<span class="keyword">var</span> handlelist = <span class="keyword">this</span>.promise.queue;
	<span class="keyword">var</span> handler = <span class="literal">null</span>;
	<span class="comment">//var returnVal = obj;</span>
	<span class="keyword">if</span>(obj) <span class="keyword">this</span>.lastReturnValue = obj;
	<span class="keyword">this</span>.promise.status = <span class="string">'resolved'</span>;
	<span class="keyword">while</span>((handler = handlelist.shift()) != <span class="literal">undefined</span>){
		<span class="keyword">if</span> (handler&&handler.resolve) {
			<span class="keyword">this</span>.lastReturnValue = handler.resolve.call(<span class="keyword">this</span>,<span class="keyword">this</span>.lastReturnValue);
			<span class="keyword">if</span> (<span class="keyword">this</span>.lastReturnValue && <span class="keyword">this</span>.lastReturnValue.isPromise) {
				<span class="keyword">this</span>.lastReturnValue.queue = handlelist;
				<span class="keyword">return</span>;
			}
		}

	}
}


Deffered.prototype.reject = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span>{</span>
	<span class="keyword">var</span> handlelist = <span class="keyword">this</span>.promise.queue;
	<span class="keyword">var</span> handler = <span class="literal">null</span>;
	<span class="comment">//var returnVal = obj;</span>
	<span class="keyword">if</span>(obj) <span class="keyword">this</span>.lastReturnValue = obj;
	<span class="keyword">this</span>.promise.status = <span class="string">'rejected'</span>;
	<span class="keyword">while</span>((handler = handlelist.shift()) != <span class="literal">undefined</span>){
		<span class="keyword">if</span> (handler&&handler.reject) {
			<span class="keyword">this</span>.lastReturnValue = handler.reject.call(<span class="keyword">this</span>,<span class="keyword">this</span>.lastReturnValue);
			<span class="keyword">if</span> (<span class="keyword">this</span>.lastReturnValue && <span class="keyword">this</span>.lastReturnValue.isPromise) {
				<span class="keyword">this</span>.lastReturnValue.queue = handlelist;
				<span class="keyword">return</span>;
			}
		}
	}
}


<span class="keyword">var</span> Promise = <span class="function"><span class="keyword">function</span><span class="params">(_deffered)</span>{</span>
	<span class="keyword">this</span>.queue = [];
	<span class="keyword">this</span>.isPromise = <span class="literal">true</span>;
	<span class="keyword">this</span>._d = _deffered;
	<span class="keyword">this</span>.status = <span class="string">'started'</span>;<span class="comment">//three status  started   resolved  rejected</span>

}

Promise.prototype.then = <span class="function"><span class="keyword">function</span><span class="params">(onfulled,onrejected)</span>{</span>
	<span class="keyword">var</span> handler = {};
	<span class="keyword">var</span> _d = <span class="keyword">this</span>._d;
	<span class="keyword">var</span> status = <span class="keyword">this</span>.status;
	<span class="keyword">if</span> (onfulled) {
		handler[<span class="string">'resolve'</span>] = onfulled;
	}

	<span class="keyword">if</span> (onrejected) {
		handler[<span class="string">'reject'</span>] = onrejected;
	}
	<span class="keyword">this</span>.queue.push(handler);

	<span class="keyword">if</span> (status == <span class="string">'resolved'</span>) _d.resolve();
	<span class="keyword">if</span> (status == <span class="string">'rejected'</span>) _d.reject();
	<span class="keyword">return</span> <span class="keyword">this</span>;
}
</pre></td></tr></table></figure>

<p>首先我们先看promise部分，Promise有三种状态。未完成（started），已完成（resolved），失败（rejected）。Promise只能是由未完成往 另外两种状态转变，而且不可逆。<br>我们先是定义了一个队列，用来存放所有的回调函数包括正确完成的回调（onfulled）和失败的回调（onrejected）。<br><code>this.isPromise = true;</code>用来表明是一个promise对象。<br><code>this._d = _deffered;</code>是用来存储与这个promise对象对应的deffered对象的。<br>deffered对象一般具有resolve还有reject方法分别代表开始执行队列里handle相应的回调。</p>
<p>promise有一个then方法，用来声明完成的函数，还有失败的函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">this</span>.queue.push(handler);
<span class="keyword">if</span> (status == <span class="string">'resolved'</span>) _d.resolve();
<span class="keyword">if</span> (status == <span class="string">'rejected'</span>) _d.reject();
</pre></td></tr></table></figure>

<p>这段代码先是将回调对象储存起来，后面的两个判断，是用来当一个promise对象已经不是未完成时直接调用then添加的回调。</p>
<p>下面我们看下Deffered对象，首先有个promise对象的引用。还有个lastReturnValue，这个是用来储存promise队列里面的handle回调的返回值的。</p>
<p>我们重点看下<code>Deffered.prototype.resolve</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>Deffered.prototype.resolve = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span>{</span>
	<span class="keyword">var</span> handlelist = <span class="keyword">this</span>.promise.queue;
	<span class="keyword">var</span> handler = <span class="literal">null</span>;
	<span class="comment">//var returnVal = obj;</span>
	obj && <span class="keyword">this</span>.lastReturnValue = obj;
	<span class="keyword">this</span>.promise.status = <span class="string">'resolved'</span>;
	<span class="keyword">while</span>((handler = handlelist.shift()) != <span class="literal">undefined</span>){
		<span class="keyword">if</span> (handler&&handler.resolve) {
			<span class="keyword">this</span>.lastReturnValue = handler.resolve.call(<span class="keyword">this</span>,<span class="keyword">this</span>.lastReturnValue);
			<span class="keyword">if</span> (<span class="keyword">this</span>.lastReturnValue && <span class="keyword">this</span>.lastReturnValue.isPromise) {
				<span class="keyword">this</span>.lastReturnValue.queue = handlelist;
				<span class="keyword">return</span>;
			}
		}

	}
}
</pre></td></tr></table></figure>

<p>还记得我们怎么调用的吗？</p>
<p>没错，我们先要创建一个deffered对象，之后返回他的promise对象。通过then，我们给这个promise添加了很多的异步正确完成回调。同时这些回调也返回自己的promise对象。此时backHome对应的deffered对象关联的promise里面已经通过then添加了很多回调函数。但是并未执行。</p>
<p>在start函数里面当backhome完成时 我们执行了<code>d.resolve(&#39;done----backhome&#39;);</code><br>这个 时候调用了backHome对应的deffered对象的resolve。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">while</span>((handler = handlelist.shift()) != <span class="literal">undefined</span>){
	<span class="keyword">if</span> (handler&&handler.resolve) {
		<span class="keyword">this</span>.lastReturnValue = handler.resolve.call(<span class="keyword">this</span>,<span class="keyword">this</span>.lastReturnValue);
		<span class="keyword">if</span> (<span class="keyword">this</span>.lastReturnValue && <span class="keyword">this</span>.lastReturnValue.isPromise) {
			<span class="keyword">this</span>.lastReturnValue.queue = handlelist;
			<span class="keyword">return</span>;
		}
	}

}
</pre></td></tr></table></figure>

<p>backHome对应的deffered对象的resolve里面开始循环调用回调队列里的函数。同时backHome对应的deffered对象关联的promise的状态已经变成了已完成。<br>请注意下面这个判断：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> (<span class="keyword">this</span>.lastReturnValue && <span class="keyword">this</span>.lastReturnValue.isPromise) {
	<span class="keyword">this</span>.lastReturnValue.<span class="built_in">queue</span> = handlelist;
	<span class="keyword">return</span>;
}
</pre></td></tr></table></figure>

<p>当then添加的是一个普通非异步函数时。就会继续取出队列的函数执行。但是当添加的函数也返回了一个promise，这时候话语权就要交给这个新的promise了，当前队列的执行就要停下来，同时将当前的操作函数队列赋值给新的peomise的队列，完成交接。之后就又是一个新的promise从未完成到另外状态的过程了，只有新的promise被resolve或者reject了，下面的才会继续执行下去。</p>
<p>可以看到通过promise和deffered，事件的声明和调用完全分开了。一个负责管理函数一个负责调用。非常灵活优雅。</p>
<blockquote>
<p>promise与很多开源库实现了，比较出名的是when.js，Q,有兴趣的可以去了解下。</p>
</blockquote>
<h2 id="尾触发机制">尾触发机制</h2>
<p>这是connect中间件使用的方式，可以串行处理异步代码。当然这只是一种实现思路，不具备通用性，所有任务都需要一个next参数。我们需要对前面的代码做些小改造。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">offWork</span><span class="params">(data,next)</span>{</span>
    console.log(<span class="string">"上班ing。。。"</span>)
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"下班了。。。"</span>)
        next(<span class="string">'传给下个任务的数据'</span>);
    },<span class="number">1000</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">backHome</span><span class="params">(data,next)</span>{</span>
    console.log(<span class="string">'上个任务传过来的数据为：'</span>+data);
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"到家了！！！"</span>)
        next(<span class="string">'传给下个任务的数据'</span>);
    },<span class="number">1000</span>);
    console.log(<span class="string">"回家ing。。。"</span>)
}

App = {
	handles:[],
	<span class="keyword">use</span>:<span class="function"><span class="keyword">function</span><span class="params">(handle)</span>{</span>
	    <span class="keyword">if</span>(<span class="keyword">typeof</span> handle == <span class="string">'function'</span>)
		  App.handles.push(handle);
	},
	next:<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
	    <span class="keyword">var</span> handlelist = App.handles;
	    <span class="keyword">var</span> handle = <span class="literal">null</span>;
	    <span class="keyword">var</span> _next = App.next;
	    <span class="keyword">if</span>((handle = handlelist.shift()) != <span class="literal">undefined</span>){
	        handle.call(App,data,_next);
	    }
	},
	start:<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
	    App.next(data);
	}
}
</pre></td></tr></table></figure>

<p>每个任务，都必须有两个参数，next是一个函数引用，等当前任务结束时，需要手动调用next，就可以启动下一个任务的运行，当然可以通过next(data)传一些数据给下一个任务。任务的第一个参数就是上一个任务调next的时候传过来的数据。</p>
<p>于是我们可以这么调用了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>
App<span class="preprocessor">.use</span>(offWork)<span class="comment">;</span>
App<span class="preprocessor">.use</span>(backHome)<span class="comment">;</span>
App<span class="preprocessor">.start</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>显然调用过程非常直观，这个方式的缺点就是需要对每个任务进行相应的改造。而且只能是串行的执行，不能很好的发挥异步的优势。</p>
<h2 id="wind-js">wind.js</h2>
<p>还有种比较知名的方式，是国内的程序员老赵的wind.js,它使用了一种完全不同的异步实现方式。前面的所有方式都要改变我们正常的编程习惯，但是wind.js不用。它提供了一些服务函数使得我们可以按照正常的思维去编程。</p>
<p>下面是一个简单的冒泡排序的算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> compare = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
    <span class="keyword">return</span> x - y;
}

<span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span> <span class="params">(a, i, j)</span> {</span>
    <span class="keyword">var</span> t = a[i]; a[i] = a[j]; a[j] = t;
}

<span class="keyword">var</span> bubbleSort = <span class="function"><span class="keyword">function</span> <span class="params">(array)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) {
        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">array</span>.length - i - <span class="number">1</span>; j++) {
            <span class="keyword">if</span> (compare(<span class="keyword">array</span>[j], <span class="keyword">array</span>[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) {
                swap(<span class="keyword">array</span>, j, j + <span class="number">1</span>);
            }
        }
    }
}
</pre></td></tr></table></figure>

<p>很简单就不讲解了，现在的问题是我们如果要做一个动画，一点点的展示这个过程呢。<br>于是我们需要给compare加个延时，并且swap后重绘数字展现。<br>可javascript是不支持sleep这样的休眠方法的。如果我们用setTimeout模拟，又不能保证比较的顺序的正确执行。</p>
<p>可是有了windjs后我们就可以这么写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">var</span> compareAsync = <span class="keyword">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
    <span class="variable">$await</span>(Wind.Async.sleep(<span class="number">10</span>)); <span class="comment">// 暂停10毫秒</span>
    <span class="keyword">return</span> x - y;
}));

<span class="keyword">var</span> swapAsync = <span class="keyword">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(a, i, j)</span> {</span>
    <span class="variable">$await</span>(Wind.Async.sleep(<span class="number">20</span>)); <span class="comment">// 暂停20毫秒</span>
    <span class="keyword">var</span> t = a[i]; a[i] = a[j]; a[j] = t;
    paint(a); <span class="comment">// 重绘数组</span>
}));

<span class="keyword">var</span> bubbleSortAsync = <span class="keyword">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(array)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) {
        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">array</span>.length - i - <span class="number">1</span>; j++) {
            <span class="comment">// 异步比较元素</span>
            <span class="keyword">var</span> r = <span class="variable">$await</span>(compareAsync(<span class="keyword">array</span>[j], <span class="keyword">array</span>[j + <span class="number">1</span>]));
            <span class="comment">// 异步交换元素</span>
            <span class="keyword">if</span> (r &gt; <span class="number">0</span>) <span class="variable">$await</span>(swapAsync(<span class="keyword">array</span>, j, j + <span class="number">1</span>));
        }
    }
}));
</pre></td></tr></table></figure>

<p>注意其中最终要的几个辅助函数：</p>
<ol>
<li>eval(Wind.compile(“async”, func) 这个函数用来定义一个“异步函数”。这样的函数定义方式是“模板代码”，没有任何变化，可以认做是“异步函数”与“普通函数”的区别。</li>
<li>Wind.Async.sleep() 这是windjs对于settimeout的一个封装，就是用上面的 eval(Wind.compile来定义的。</li>
<li>$await()所有经过定义的异步函数，都可以使用这个方法 来等待异步函数的执行完毕。</li>
</ol>
<p>这样上面的代码就可以很容易的理解了。compare，swap都被弄成了异步函数，然后使用$await等待他们的执行完毕。可以看到跟我们之前的写法比起来，实现思路几乎一样，只是多了些辅助函数。相当的创新。</p>
<blockquote>
<p>windjs的实现原理，暂时没怎么看，这是一种预编译的思路。之后有空看看也来实现一个简单的demo。</p>
</blockquote>
<h2 id="generator_and_co">generator and co</h2>
<p>什么是generator？generator是javascript1.7的内容，是 ECMA-262 在第六个版本，即我们说的 Harmony 中所提出的新特性。所以，没错这个特性支持很一般。<br>有下面几种办法体验generator：</p>
<ul>
<li>node v0.11 可以使用 (node —harmony)</li>
<li>使用gnode来使用，不过据说性能一般</li>
<li>使用chrome体验，打开chrome://flags/, 搜索harmony, 启用, 重启chrome即可。<br>我们看个简单的例子:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>

<span class="coffeescript"><span class="reserved">function</span>* start() {
  <span class="reserved">var</span> a = yield <span class="string">'start'</span>;
  <span class="built_in">console</span>.log(a);
  <span class="reserved">var</span> b = yield <span class="string">'running'</span>;
  <span class="built_in">console</span>.log(b);
  <span class="reserved">var</span> c = yield <span class="string">'end'</span>;
  <span class="built_in">console</span>.log(c);
  <span class="keyword">return</span> <span class="string">'over'</span>;
}

<span class="reserved">var</span> it = start();
<span class="built_in">console</span>.log(it.next(<span class="number">11</span>));<span class="regexp">//</span>Object {<span class="attribute">value</span>: <span class="string">"start"</span>, <span class="attribute">done</span>: <span class="literal">false</span>}
<span class="built_in">console</span>.log(it.next(<span class="number">22</span>));<span class="regexp">//</span><span class="number">22</span>  object {<span class="attribute">value</span>: <span class="string">'running'</span>, <span class="attribute">done</span>: <span class="literal">false</span>}
<span class="built_in">console</span>.log(it.next(<span class="number">333</span>));<span class="regexp">//</span><span class="number">333</span> Object {<span class="attribute">value</span>: <span class="string">'end'</span>, <span class="attribute">done</span>: <span class="literal">false</span>}
<span class="built_in">console</span>.log(it.next(<span class="number">444</span>));<span class="regexp">//</span><span class="number">444</span> Object {<span class="attribute">value</span>: <span class="string">"over"</span>, <span class="attribute">done</span>: <span class="literal">true</span>}</span>
</pre></td></tr></table></figure>

<p>其实很好理解，<code>function* functionname() {</code>用来声明一个<code>generator function</code>。通过执行<code>generator function</code>我们得到一个<code>generator</code>，也就是it。</p>
<p>当我们调用it.next(11)的时候，代码会执行到<code>var a = yield &#39;start&#39;;</code>然后断点。注意这个时候还没有进行对a的赋值,这个时候it.next(11)返回一个对象有两个属性，value代表yield返回的东西，可以是值也可以是函数。done代表当前generator有没有结束。<br>当我们调用 it.next(22)的时候，代码开始执行到<code>var b = yield running;</code>。此时你发现打出了22，没错a的值被赋为22，也就是说next里面的参数会作为上一个yield的返回值。</p>
<p>一直到调用it.next(444)，代码一直执行到return，这个时候 函数的返回值就作为 next返回对象的value值，也就是我们的over。</p>
<p>这就是generator的全部内容了</p>
<blockquote>
<p>详细的可以参考这边的MDN的介绍，猛戳<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7#Generators" target="_blank">这里</a></p>
</blockquote>
<p>那我们如何将它应用在我们的异步代码上呢？<br>实际上TJ大神已经做了这件事，编写了一个CO的库。<br>我们简单探讨下CO的原理<br>假设我们需要知道小胖回家的总时间。<br>有了co框架后 我们可以这么完成我们上面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">offWork</span><span class="params">(callback)</span>{</span>
    console.log(<span class="string">"上班ing。。。"</span>)
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"下班了。。。"</span>)
        callback(<span class="number">1</span>);
    },<span class="number">1000</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">backHome</span><span class="params">(callback)</span>{</span>
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"到家了！！！"</span>)
        callback(<span class="number">2</span>);
    },<span class="number">2000</span>);
    console.log(<span class="string">"回家ing。。。"</span>)
}

co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> {</span>
  <span class="keyword">var</span> a;
  a = <span class="keyword">yield</span> offWork;
  console.log(a);
  a = <span class="keyword">yield</span> backHome;
  console.log(a);
})(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> {</span>
  console.log(data);
})


<span class="comment">//结果为：</span>
<span class="comment">/*
上班ing。。。
下班了。。。
1
回家ing。。。
到家了！！！
2
2
*/</span>
</pre></td></tr></table></figure>

<p>co函数接收一个generatorfunction作为参数，生成一个实际操作函数。这个实际操作函数可以接收一个callback来传入最后一个异步任务的回调值。</p>
<p>可以看到我们可以直接使用<code>a = yield offWork;</code>来获取异步函数offwork的返回值。真的是太赞了，而且我们可以提供一个回调用来接收最后回调的值，这边就是backHome回调的值。</p>
<p>下面我们来实现这个函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> *<span class="title">co</span><span class="params">(generatorFunction)</span>{</span>
   <span class="keyword">var</span> generator = generatorFunction();
   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(cb)</span>{</span>
        <span class="keyword">var</span> iterator = <span class="literal">null</span>;
        <span class="keyword">var</span> _next = <span class="function"><span class="keyword">function</span> <span class="params">(args)</span>{</span>
            iterator = generator.next(args);
            <span class="keyword">if</span>(iterator.done){
                cb&&cb(args);
            }<span class="keyword">else</span>{
                iterator.value(_next);
            }
        }
        _next();
   }

}
</pre></td></tr></table></figure>

<p>代码很简单，就是不停的调用generator的next，当next返回的对象的done属性不为空时就执行返回的异步函数。注意那边args的传递。<br>可以看到短短几行就实现了这个功能，当然实际的co框架比这个复杂的多，这边只是实现了最基础的原理。</p>
<blockquote>
<p>使用co时，yield的必须是thunk函数，thunk函数就是那种参数只有一个callback的函数，这个可以使用一些方法转换，也有一些库支持，可以了解下thunkify 或者thunkify-wrap。</p>
</blockquote>
<p>这边给个简单的普通nodejs读文件函数到thunk函数的转换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">(file)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(fn)</span>{</span>
    fs.readFile(file, <span class="string">'utf8'</span>, fn);
  }
}
<span class="comment">//于是可以这么用</span>

co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> {</span>
  <span class="keyword">var</span> a;
  a = <span class="keyword">yield</span> read(<span class="string">'.gitignore'</span>);

})(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> {</span>
})
</pre></td></tr></table></figure>

<h2 id="结语">结语</h2>
<p>javascript是一门短时间内就创出的语言，虽然很灵活，但是很容易写出糟糕的代码。异步编程，在性能问题上尤其是io处理上是它的优势，但是同时也是它的劣势，大部分人都无法很好的组织异步代码。于是就出现了一大堆的库，来给它擦屁股。不得不说人类的智慧是无限的。上面这么多的异步流程库的实现就是很好的例子，没有最好的语言，只有最合适的。也没有最好的异步实现方式，关键是找到合适的。</p>
<p>除了上面介绍的这些实现异步编程的思路以外，其实还有很多优秀的实现方式，以后有空再研究下step，async等等的实现方式。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/javascript/">javascript</a><a href="/tags/异步编程/">异步编程</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/javascript/">javascript</a>►<a class="article-category-link" href="/categories/javascript/nodejs/">nodejs</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://purplebamboo.github.com/2014/04/08/nodejs-async/" data-title="javascript 异步编程总结 | blog of purplebamboo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/05/14/start_with_vagrant/" title="开始使用vagrant无痛开发">
  <strong>PREVIOUS:</strong><br/>
  <span>
  开始使用vagrant无痛开发</span>
</a>
</div>


<div class="next">
<a href="/2014/02/09/javascript-watch-img-width-height/"  title="javascript 上传图片 检测宽度 高度 文件大小">
 <strong>NEXT:</strong><br/> 
 <span>javascript 上传图片 检测宽度 高度 文件大小
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个生活例子"><span class="toc-number">1.</span> <span class="toc-text">一个生活例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件发布订阅方式"><span class="toc-number">2.</span> <span class="toc-text">事件发布订阅方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise_和_Defferred"><span class="toc-number">3.</span> <span class="toc-text">Promise 和 Defferred</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尾触发机制"><span class="toc-number">4.</span> <span class="toc-text">尾触发机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wind-js"><span class="toc-number">5.</span> <span class="toc-text">wind.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generator_and_co"><span class="toc-number">6.</span> <span class="toc-text">generator and co</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">7.</span> <span class="toc-text">结语</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/angularjs记录/" title="angularjs记录">angularjs记录<sup>9</sup></a></li>
		
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/categories/iconfont技术/" title="iconfont技术">iconfont技术<sup>2</sup></a></li>
		
			<li><a href="/categories/javascript/" title="javascript">javascript<sup>18</sup></a></li>
		
			<li><a href="/categories/javascript/nodejs/" title="nodejs">nodejs<sup>2</sup></a></li>
		
			<li><a href="/categories/从零单排/" title="从零单排">从零单排<sup>1</sup></a></li>
		
			<li><a href="/categories/各种知识点记录/" title="各种知识点记录">各种知识点记录<sup>1</sup></a></li>
		
			<li><a href="/categories/javascript/源码分析/" title="源码分析">源码分析<sup>7</sup></a></li>
		
			<li><a href="/categories/系统环境/" title="系统环境">系统环境<sup>1</sup></a></li>
		
			<li><a href="/categories/angularjs记录/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Filters/" title="Filters">Filters<sup>1</sup></a></li>
		
			<li><a href="/tags/analyze/" title="analyze">analyze<sup>1</sup></a></li>
		
			<li><a href="/tags/angular/" title="angular">angular<sup>2</sup></a></li>
		
			<li><a href="/tags/angularjs/" title="angularjs">angularjs<sup>7</sup></a></li>
		
			<li><a href="/tags/ast/" title="ast">ast<sup>1</sup></a></li>
		
			<li><a href="/tags/async/" title="async">async<sup>1</sup></a></li>
		
			<li><a href="/tags/border-shadow/" title="border-shadow">border-shadow<sup>1</sup></a></li>
		
			<li><a href="/tags/chunked/" title="chunked">chunked<sup>1</sup></a></li>
		
			<li><a href="/tags/class/" title="class">class<sup>1</sup></a></li>
		
			<li><a href="/tags/co/" title="co">co<sup>2</sup></a></li>
		
			<li><a href="/tags/comet/" title="comet">comet<sup>1</sup></a></li>
		
			<li><a href="/tags/controllers/" title="controllers">controllers<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/generator/" title="generator">generator<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
		
			<li><a href="/tags/html/" title="html">html<sup>1</sup></a></li>
		
			<li><a href="/tags/iconfont/" title="iconfont">iconfont<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>15</sup></a></li>
		
			<li><a href="/tags/koa/" title="koa">koa<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://ued.taobao.com/" target="_blank">淘宝UED</a> </li>            <li><a href="http://www.aliued.com/" target="_blank">Alibaba国际站UED</a> </li>            <li><a href="http://china.aliued.com/" target="_blank">Alibaba中文站UED</a> </li>            <li><a href="http://ued.alipay.com/" target="_blank"> 支付宝UED</a> </li>            <li><a href="http://ued.tmall.com/" target="_blank">天猫UED</a> </li><li><a href="http://ur.alibaba-inc.com">阿里用户体验中心</a> </li>	 <li><a href="http://www.uisdc.com" target="_blank">优秀网页设计</a> </li>
      
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2017 
		
		<a href="http://purplebamboo.github.com" target="_blank" title="purplebamboo">purplebamboo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"cherishpeace"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script type="text/javascript">
  $(function(){
    window.onscroll = function(){
      //console.log($(document).scrollTop()+"px")
      $('.background-container .bg-dy2').css('backgroundPosition','0 '+$(document).scrollTop()+"px");
    }

  })
</script>
<div class="background-container">
  <div class="bg-dy1">

  </div>
  <div class="bg-dy2">

  </div>

</div

  </body>
</html>
