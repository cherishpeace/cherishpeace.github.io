
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>javascript oo实现 | blog of purplebamboo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="purplebamboo">
    
    <meta name="description" content="很久很久以前，我还是个phper，第一次接触javascript觉得好神奇。跟传统的oo类概念差别很大。记得刚毕业面试，如何在javascript里面实现class一直是很热门的面试题，当前面试百度就被问到了，当年作为一个小白只是网上随便搜搜应付了下。= =现在发现当时知道的还是太少太少。今天整理了">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="blog of purplebamboo" title="blog of purplebamboo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="blog of purplebamboo">blog of purplebamboo</a></h1>
				<h2 class="blog-motto">dota诚可贵，coding价更高，若为女朋友，二者皆可抛。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:purplebamboo.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/07/13/javascript-oo-class/" title="javascript oo实现" itemprop="url">javascript oo实现</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://purplebamboo.github.com" title="purplebamboo">purplebamboo</a>
    </p>
  <p class="article-time">
    <time datetime="2014-07-13T13:15:57.000Z" itemprop="datePublished">7月 13 2014</time>
    更新日期:<time datetime="2014-08-20T23:19:06.000Z" itemprop="dateModified">8月 21 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始时代最简单的oo实现"><span class="toc-number">1.</span> <span class="toc-text">原始时代最简单的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#石器时代的oo实现"><span class="toc-number">2.</span> <span class="toc-text">石器时代的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工业时代的oo实现"><span class="toc-number">3.</span> <span class="toc-text">工业时代的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现代科技时代的oo实现"><span class="toc-number">4.</span> <span class="toc-text">现代科技时代的oo实现</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#John_Resig的实现方式"><span class="toc-number">4.1.</span> <span class="toc-text">John Resig的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P-js的实现"><span class="toc-number">4.2.</span> <span class="toc-text">P.js的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阿拉蕾的实现方式"><span class="toc-number">4.3.</span> <span class="toc-text">阿拉蕾的实现方式</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#未来科技的oo实现"><span class="toc-number">5.</span> <span class="toc-text">未来科技的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">6.</span> <span class="toc-text">结语</span></a></li></ol>
		</div>
		
		<p>很久很久以前，我还是个phper，第一次接触javascript觉得好神奇。跟传统的oo类概念差别很大。记得刚毕业面试，如何在javascript里面实现class一直是很热门的面试题，当前面试百度就被问到了，当年作为一个小白只是网上随便搜搜应付了下。= =现在发现当时知道的还是太少太少。今天整理了下javascript的oo实现，发现知道的越多，越发现知识真是无穷无尽。</p>
<h2 id="原始时代最简单的oo实现">原始时代最简单的oo实现</h2>
<p>javascript虽然没有class的概念，但是它的函数却是可以new出来一个对象的。所以一个最简单的class就可以用function来模拟出来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span>{</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="keyword">this</span>.name + <span class="string">"is running!!"</span>);
    }
}

<span class="keyword">var</span> pet = <span class="keyword">new</span> Animal(<span class="string">"pet"</span>);
pet.run();<span class="comment">//petis running!!</span>
</pre></td></tr></table></figure>

<p>这样 pet就有了属性，有了方法，不过这种写法毫无继承性，扩展性。比如我们要实现个dog类，只能把属性方法再写一遍。而且每个new出来的对象都有自己的方法，造成资源浪费。</p>
<p>在javascript里面有个原型链的概念，每一个函数都有一个prototype对象属性。这样通过这个函数new出来的对象会自动具有<code>__proto__</code>属性指向函数的prototype对象。说白了所有的实例对象都会共用一个prototype对象，并且调用一个属性或者方法时在自己上面找不到，就会找<code>__proto__</code>对象有没有，之后一直往上追溯一直到找到为止。具体表现为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="reserved">function</span> Animal(name){
    <span class="keyword">this</span>.name = name;
}
Animal.prototype.run = <span class="reserved">function</span>(){
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"is running!!"</span>);
}
<span class="reserved">var</span> a = <span class="keyword">new</span> Animal(<span class="string">"a"</span>);
<span class="reserved">var</span> b = <span class="keyword">new</span> Animal(<span class="string">"b"</span>);
<span class="built_in">console</span>.log(Animal.prototype) <span class="regexp">//</span>Animal {} 
<span class="built_in">console</span>.log(Animal.prototype <span class="keyword">instanceof</span> Object) <span class="regexp">//</span><span class="literal">true</span> prototype是个对象
<span class="built_in">console</span>.log(Animal.prototype.constructor == Animal)<span class="regexp">//</span><span class="literal">true</span>
<span class="built_in">console</span>.log(a.__proto__ == Animal.prototype) <span class="regexp">//</span><span class="literal">true</span> __proto__在<span class="keyword">new</span>的时候会自动加载在实例对象上。在现代浏览器里可以看到
<span class="built_in">console</span>.log(b.__proto__ == Animal.prototype) <span class="regexp">//</span><span class="literal">true</span>
<span class="built_in">console</span>.log(a.__proto__.__proto__) <span class="regexp">//</span>Object {} 最后会找到最上面的boject对象
<span class="built_in">console</span>.log(a.__proto__.run == a.run) <span class="regexp">//</span><span class="literal">true</span>
<span class="built_in">console</span>.log(a.__proto__.run == a.prototype.run) <span class="regexp">//</span><span class="literal">true</span>
</pre></td></tr></table></figure>

<p>所以，在prototype对象上定义的方法会被所有实例共享，这不就是复用吗？<br>于是有了基于原型链的继承的写法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span>{</span>
    <span class="keyword">this</span>.name = name;
}
Animal.prototype.run = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span>.name + <span class="string">"is running!!"</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(name)</span>{</span>
    <span class="comment">//调用父类的构造函数，通过改变this指向将属性赋值到新的实例对象</span>
    Animal.call(<span class="keyword">this</span>,name);
}
Dog.prototype = <span class="keyword">new</span> Animal();
<span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"dog"</span>);
dog.run();<span class="comment">//dog is running!!</span>
</pre></td></tr></table></figure>

<p>可以看到我们将Animal的实例对象暂且叫做a，作为 Dog的prototype，这样 Dog的实例对象dog的<code>__proto__</code>指向Dog的prototype也就是a,a的<code>__proto__</code>再指向Animal的prototype对象，这个对象上有run方法。于是我们调用<code>dog.run()</code>的时候会一层层的往上追溯一直找到run方法执行。于是通过原型链我们就让 Dog继承了Animal的方法run。</p>
<blockquote>
<p>需要注意的是，如果在子类的prototype对象上也有run方法，就会覆盖父类的，因为查找时在自己上面就找到了，就不会向上回溯了。</p>
</blockquote>
<p>上面是原型链方法的继承。而属性我们则是通过调用父类的构造函数来赋值的。因为属性不能所有的实例都公用，应该每个人都有自己的一份，所以不能放在原型上。</p>
<p>上面就是原始时代最简单的类继承了。</p>
<h2 id="石器时代的oo实现">石器时代的oo实现</h2>
<p>这个时代javascript变得比较重要了，作为非常有用的特性，oo开始被很多人研究。</p>
<p>首先上面的那种简单oo实现方式，其实是有很多问题的。<br>1.没有实现传统oo该有的super方法来调用父类方法。<br>作为oo，怎么能没有super呢。作为我们前端界宗师一般的人物。Douglas 有一篇经典<a href="http://javascript.crockford.com/inheritance.html" target="_blank">文章</a>。不过貌似有很多问题。国内的玉伯分析过。在<a href="http://www.iteye.com/topic/248933" target="_blank">这里</a></p>
<p>最后Douglas总结出来：</p>
<blockquote>
<p>我编写 JavaScript 已经 8 个年头了，从来没有一次觉得需要使用 uber 方法。在类模式中，super 的概念相当重要；但是在原型和函数式模式中，super 的概念看起来是不必要的。现在回顾起来，我早期在 JavaScript 中支持类模型的尝试是一个错误。</p>
</blockquote>
<p>2.直接将父类实例作为子类的原型，简单粗暴造成多余的原型属性。还有construct的问题。<br>这个问题主要是之前代码里面这一句造成的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>Dog.prototype = <span class="keyword">new</span> Animal();
<span class="regexp">//</span><span class="reserved">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"dog"</span>);
<span class="regexp">//</span><span class="built_in">console</span>.log(dog.__proto__)     Animal {<span class="attribute">name</span>: <span class="literal">undefined</span>}
</pre></td></tr></table></figure>

<p>执行<code>new Animal()</code>就会执行animal的构造函数，就会在Dog.prototype生成多余的属性值，这边是name。而一般属性值为了复用是不能放在原型对象上的。并且由于dog有自己的name属性，原型上的是多余的。</p>
<p>还有construct的问题。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>console.<span class="keyword">log</span>(dog.constructor == Animal) <span class="comment">//true</span>
console.<span class="keyword">log</span>(dog.constructor == Dog) <span class="comment">//false</span>
</pre></td></tr></table></figure>

<p>显然这不是我们希望看到的。</p>
<p>所以我们要对上面做些改良：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{}</span>;</span>
F.prototype = Animal.prototype;
Dog.prototype = <span class="keyword">new</span> F()；
Dog.prototype.<span class="keyword">constructor</span> = Dog;
</pre></td></tr></table></figure>

<p>我们可以封装下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">objCreate</span><span class="params">(prototype)</span>{</span>
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
    F.prototype = prototype;
    <span class="keyword">return</span> <span class="keyword">new</span> F();
}
<span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(subclass,parentclass)</span>{</span>
    subclass.prototype = objCreate(parentclass.prototype);
    subclass.prototype.constructor = subclass;
}
</pre></td></tr></table></figure>

<p>于是继承可以写成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span>{</span>
    <span class="keyword">this</span>.name = name;
}
Animal.prototype.run = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span>.name + <span class="string">"is running!!"</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(name)</span>{</span>
    <span class="comment">//调用父类的构造函数，通过改变this指向将属性赋值到新的实例对象</span>
    Animal.call(<span class="keyword">this</span>,name);
}
inherit(Dog,Animal);
<span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"dog"</span>);
dog.run();<span class="comment">//dog is running!!</span>
</pre></td></tr></table></figure>

<p>当年大学毕业面试，也就到这个程度了。 = =</p>
<h2 id="工业时代的oo实现">工业时代的oo实现</h2>
<p>这个时代，各种javascript类库像雨后春笋般涌现了出来。<br>上面最后给出的方案，使用起来还是很不便，比如需要自己手动维护在构造函数里调用父类构造函数。同时继承写法对不了接原理的比较容易出错。</p>
<p>这个时候涌现了一大堆的类库的实现：</p>
<p>1.首先有些类库决定跳出传统oo的思维。不一定非要实现传统oo的继承。归根到底我们是为了复用。于是出现了很多轻量级的复用方式。<br>比如jquery的extend：<a href="http://api.jquery.com/jQuery.extend/" target="_blank">http://api.jquery.com/jQuery.extend/</a><br>还有kissy的mix：<a href="http://docs.kissyui.com/1.3/docs/html/api/seed/kissy/mix.html?highlight=mix#seed.KISSY.mix" target="_blank">http://docs.kissyui.com/1.3/docs/html/api/seed/kissy/mix.html?highlight=mix#seed.KISSY.mix</a><br>还有kissy的argument：<a href="http://docs.kissyui.com/1.3/docs/html/api/seed/kissy/augment.html" target="_blank">http://docs.kissyui.com/1.3/docs/html/api/seed/kissy/augment.html</a><br>还有很多很多，说白了都是对象级别上的混入达到复用的地步。大部分情况下已经足够了。</p>
<p>2.当然还是有人对类的继承有需求的。<br>下面我们看下kissy的extend的实现方式。其他类库实现方式类似，kissy的我觉得算是比较有代表性了。为了演示，做了些小修改。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="comment">//这个就是我们之前实现的方法，为了演示做了些改动主要是处理了construct的问题</span>
<span class="function"><span class="keyword">function</span> <span class="title">objCreate</span><span class="params">(prototype，construct)</span>{</span>
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
    F.prototype = prototype;
    <span class="keyword">var</span> newPro = <span class="keyword">new</span> F();
    newPro.construct = construct;<span class="comment">//维护构造函数的改变</span>
    <span class="keyword">return</span> newPro;
}
<span class="comment">//mix是个辅助方法，这边给个最简单的实现，其实kissy里面的复杂的多。这边不考虑深度遍历等等，只是最简单的实现。</span>
<span class="function"><span class="keyword">function</span> <span class="title">mix</span><span class="params">(r, s)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> s) {
    <span class="keyword">if</span> (s.hasOwnProperty(p)) {
        r[p] = s[p]
    }
  }
}
<span class="comment">//下面是kissy的实现r代表子类 s代表父类，px代表最后会混入子类原型上的属性，sx代表会混入子类函数上面的属性，也就是可以当做静态方法。</span>
<span class="comment">//http://docs.kissyui.com/1.3/docs/html/api/seed/kissy/extend.html?highlight=extend#seed.KISSY.extend</span>
<span class="function"><span class="keyword">function</span> <span class="title">extend</span> <span class="params">(r, s, px, sx)</span> {</span>
    <span class="keyword">if</span> (!s || !r) {
        <span class="keyword">return</span> r;
    }
    <span class="keyword">var</span> sp = s.prototype,
        rp;
    <span class="comment">//针对父类生成一个原型。跟之前我们写的一致</span>
    rp = createObject(sp, r);
    <span class="comment">//不是简单的直接复制原型对象，而是先把以前原型的方法跟要继承的合并之后再一起赋值</span>
    r.prototype = S.mix(rp, r.prototype);
    
    <span class="comment">//为子类增加superclass属性，指向一个父类对象，这样就可以调用父类的方法了。这边是实现比较巧妙的地方</span>
    r.superclass = createObject(sp, s);
    <span class="comment">//下面就是往原型还有函数上混入方法了</span>
    <span class="comment">// add prototype overrides</span>
    <span class="keyword">if</span> (px) {
        S.mix(rp, px);
    }

    <span class="comment">// add object overrides</span>
    <span class="keyword">if</span> (sx) {
        S.mix(r, sx);
    }

    <span class="keyword">return</span> r;
}
</pre></td></tr></table></figure>

<p>有了kissy的extend我们可以这么用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">(name)</span>{</span>
    <span class="keyword">this</span>.name = name;
}
Animal.prototype.run = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    console.log(<span class="keyword">this</span>.name + <span class="string">"is running!!"</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(name)</span>{</span>
    
    <span class="comment">//Animal.call(this,name);</span>
    <span class="comment">//因为kissy的封装 这边可以这么用</span>
    Dog.superclass.construct.call(<span class="keyword">this</span>,name);
}
extend(Dog,Animal,{
    wang:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        console.log(<span class="string">"wang wang!!"</span>)
    }
})
<span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"dog"</span>);
dog.run();<span class="comment">//dog is running!!</span>
dog.wang();<span class="comment">//wang wang!!</span>
</pre></td></tr></table></figure>

<p>相对之前的变得清晰了很多，也更易用了。</p>
<h2 id="现代科技时代的oo实现">现代科技时代的oo实现</h2>
<p>前面的写法，目前虽然还是有很多人用，不过也渐渐过时了。上面的写法还是不够清晰，定义属性，方法都很分散，也没有多继承，等特性。我们需要像传统oo一样具有一个类工厂，可以生成一个类，属性都定义在里面。同时具有继承的方法。</p>
<p>而随着javascript成为前端唯一的语言，一代代大神前仆后继。终于开始涌现出了各种神奇的写法，下面罗列下一些我觉得特别好的实现，加上原理注释。</p>
<h3 id="John_Resig的实现方式">John Resig的实现方式</h3>
<p>作为jquery的作者。John Resig在博客里记录了一种class的实现，原文<a href="http://ejohn.org/blog/simple-javascript-inheritance/" target="_blank">在此</a><br>调用方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">var</span> Person = Class.extend({
  init: <span class="function"><span class="keyword">function</span><span class="params">(isDancing)</span>{</span>
    <span class="keyword">this</span>.dancing = isDancing;
  },
  dance: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dancing;
  }
});
 
<span class="keyword">var</span> Ninja = Person.extend({
  init: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">this</span>._super( <span class="literal">false</span> );
  },
  dance: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">// Call the inherited version of dance()</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._super();
  },
  swingSword: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
});
 
<span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="literal">true</span>);
p.dance(); <span class="comment">// =&gt; true</span>
 
<span class="keyword">var</span> n = <span class="keyword">new</span> Ninja();
n.dance(); <span class="comment">// =&gt; false</span>
n.swingSword(); <span class="comment">// =&gt; true</span>
 
<span class="comment">// Should all be true</span>
p <span class="keyword">instanceof</span> Person && p <span class="keyword">instanceof</span> Class &&
n <span class="keyword">instanceof</span> Ninja && n <span class="keyword">instanceof</span> Person && n <span class="keyword">instanceof</span> Class
</pre></td></tr></table></figure>

<p>源码解读：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="code"><pre><span class="comment">/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */</span>
<span class="comment">// Inspired by base2 and Prototype</span>
(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
  <span class="comment">//initializing是为了解决我们之前说的继承导致原型有多余参数的问题。当我们直接将父类的实例赋值给子类原型时。是会调用一次父类的构造函数的。所以这边会把真正的构造流程放到init函数里面，通过initializing来表示当前是不是处于构造原型阶段，为true的话就不会调用init。</span>
  <span class="comment">//fnTest用来匹配代码里面有没有使用super关键字。对于一些浏览器`function(){xyz;}`会生成个字符串，并且会把里面的代码弄出来，有的浏览器就不会。`/xyz/.test(function(){xyz;})`为true代表浏览器支持看到函数的内部代码，所以用`/\b_super\b/`来匹配。如果不行，就不管三七二十一。所有的函数都算有super关键字，于是就是个必定匹配的正则。</span>
  <span class="keyword">var</span> initializing = <span class="literal">false</span>, fnTest = <span class="regexp">/xyz/</span>.test(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>xyz;}) ? <span class="regexp">/\b_super\b/</span> : <span class="regexp">/.*/</span>;
 
  <span class="comment">// The base Class implementation (does nothing)</span>
  <span class="comment">// 超级父类</span>
  <span class="keyword">this</span>.Class = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
 
  <span class="comment">// Create a new Class that inherits from this class</span>
  <span class="comment">// 生成一个类，这个类会具有extend方法用于继续继承下去</span>
  Class.extend = <span class="function"><span class="keyword">function</span><span class="params">(prop)</span> {</span>
    <span class="comment">//保留当前类，一般是父类的原型</span>
    <span class="comment">//this指向父类。初次时指向Class超级父类</span>
    <span class="keyword">var</span> _super = <span class="keyword">this</span>.prototype;
   
    <span class="comment">// Instantiate a base class (but only create the instance,</span>
    <span class="comment">// don't run the init constructor)</span>
    <span class="comment">//开关 用来使原型赋值时不调用真正的构成流程</span>
    initializing = <span class="literal">true</span>;
    <span class="keyword">var</span> prototype = <span class="keyword">new</span> <span class="keyword">this</span>();
    initializing = <span class="literal">false</span>;
   
    <span class="comment">// Copy the properties over onto the new prototype</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> prop) {
      <span class="comment">// Check if we're overwriting an existing function</span>
      <span class="comment">//这边其实就是很简单的将prop的属性混入到子类的原型上。如果是函数我们就要做一些特殊处理</span>
      prototype[name] = <span class="keyword">typeof</span> prop[name] == <span class="string">"function"</span> &&
        <span class="keyword">typeof</span> _super[name] == <span class="string">"function"</span> && fnTest.test(prop[name]) ?
        (<span class="function"><span class="keyword">function</span><span class="params">(name, fn)</span>{</span>
          <span class="comment">//通过闭包，返回一个新的操作函数.在外面包一层，这样我们可以做些额外的处理</span>
          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">var</span> tmp = <span class="keyword">this</span>._super;
           
            <span class="comment">// Add a new ._super() method that is the same method</span>
            <span class="comment">// but on the super-class</span>
            <span class="comment">// 调用一个函数时，会给this注入一个_super方法用来调用父类的同名方法</span>
            <span class="keyword">this</span>._super = _super[name];
           
            <span class="comment">// The method only need to be bound temporarily, so we</span>
            <span class="comment">// remove it when we're done executing</span>
            <span class="comment">//因为上面的赋值，是的这边的fn里面可以通过_super调用到父类同名方法</span>
            <span class="keyword">var</span> ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);  
            <span class="comment">//离开时 保存现场环境，恢复值。</span>
            <span class="keyword">this</span>._super = tmp;
           
            <span class="keyword">return</span> ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
   
    <span class="comment">// 这边是返回的类，其实就是我们返回的子类</span>
    <span class="function"><span class="keyword">function</span> <span class="title">Class</span><span class="params">()</span> {</span>
      <span class="comment">// All construction is actually done in the init method</span>
      <span class="keyword">if</span> ( !initializing && <span class="keyword">this</span>.init )
        <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
    }
   
    <span class="comment">// 赋值原型链，完成继承</span>
    Class.prototype = prototype;
   
    <span class="comment">// 改变constructor引用</span>
    Class.prototype.constructor = Class;
 
    <span class="comment">// 为子类也添加extend方法</span>
    Class.extend = <span class="built_in">arguments</span>.callee;
   
    <span class="keyword">return</span> Class;
  };
})();
</pre></td></tr></table></figure>

<p>相当简单高效的实现方式，super的实现方式非常亮</p>
<h3 id="P-js的实现">P.js的实现</h3>
<p>源地址：<a href="https://github.com/jneen/pjs" target="_blank">https://github.com/jneen/pjs</a><br>pjs的一大亮点是支持私有属性，他的类工厂传递的是函数不是对象。</p>
<p>调用方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="comment">//可以生成一个可继承的对象，P接收一个函数，这个函数会传入生成后的class的原型。</span>
<span class="keyword">var</span> Animal = P(<span class="function"><span class="keyword">function</span><span class="params">(animal)</span> {</span>
  animal.init = <span class="function"><span class="keyword">function</span><span class="params">(name)</span> {</span> <span class="keyword">this</span>.name = name; };

  animal.move = <span class="function"><span class="keyword">function</span><span class="params">(meters)</span> {</span>
    console.log(<span class="keyword">this</span>.name+<span class="string">" moved "</span>+meters+<span class="string">"m."</span>);
  }
});
<span class="comment">//继承Animal。后面的snake，animal分别是前面Snake和Animal的原型。程序直接把这些对象暴露给你了。于是灵活度很高。</span>
<span class="keyword">var</span> Snake = P(Animal, <span class="function"><span class="keyword">function</span><span class="params">(snake, animal)</span> {</span>
  snake.move = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">"Slithering..."</span>);
    animal.move.call(<span class="keyword">this</span>, <span class="number">5</span>);
  };
});

<span class="keyword">var</span> Horse = P(Animal, <span class="function"><span class="keyword">function</span><span class="params">(horse, animal)</span> {</span>
  <span class="comment">//真正的私有属性，外面没法调用到</span>
  <span class="keyword">var</span> test = <span class="string">"hello world"</span>;
  horse.move = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(test);
    console.log(<span class="string">"Galloping..."</span>);
    <span class="comment">//调用父类的方法，so easy！！</span>
    animal.move.call(<span class="keyword">this</span>, <span class="number">45</span>);
  };
});
<span class="comment">//工厂方式生成对象，可以不用new</span>
<span class="keyword">var</span> sam = Snake(<span class="string">"Sammy the Python"</span>)
  , tom = Horse(<span class="string">"Tommy the Palomino"</span>)
;

sam.move()
tom.move()
</pre></td></tr></table></figure>

<p>源码解读：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="code"><pre><span class="keyword">var</span> P = (<span class="function"><span class="keyword">function</span><span class="params">(prototype, ownProperty, undefined)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">(_superclass <span class="comment">/* = Object */</span>, definition)</span> {</span>
    <span class="comment">// handle the case where no superclass is given</span>
    <span class="keyword">if</span> (definition === <span class="literal">undefined</span>) {
      definition = _superclass;
      _superclass = <span class="built_in">Object</span>;
    }

    <span class="comment">//最后返回的类就是这个，也就是我们需要的子类。这个类可以用new生成实例，也可以直接调用生成实例</span>
    <span class="function"><span class="keyword">function</span> <span class="title">C</span><span class="params">()</span> {</span>
      <span class="comment">//判断,是new的话this instanceof C就是true。否则我们自己手动new一下Bare。Bare就是为了实现这种类工厂的生成类的方式</span>
      <span class="keyword">var</span> self = <span class="keyword">this</span> <span class="keyword">instanceof</span> C ? <span class="keyword">this</span> : <span class="keyword">new</span> Bare;
      self.init.apply(self, <span class="built_in">arguments</span>);
      <span class="keyword">return</span> self;
    }

    <span class="comment">//这个就是用来实现不用new生成类的方式</span>
    <span class="function"><span class="keyword">function</span> <span class="title">Bare</span><span class="params">()</span> {</span>}
    C.Bare = Bare;

    <span class="comment">//将父类的原型赋值给Bare</span>
    <span class="comment">//这边prototype就是个字符串“prototype”变量，主要为了压缩字节少点，所以作者还单独传成变量进来 = =</span>
    <span class="keyword">var</span> _super = Bare[prototype] = _superclass[prototype];
    <span class="comment">//再生成这个空函数的实例赋值给C,Bare的原型，同时在C.p存下来</span>
    <span class="comment">//这样C,Bare都公用一个原型</span>
    <span class="keyword">var</span> proto = Bare[prototype] = C[prototype] = C.p = <span class="keyword">new</span> Bare;
    
    <span class="keyword">var</span> key;
    <span class="comment">//改变constructor指向</span>
    proto.constructor = C;
<span class="comment">//上面几部其实还是实现的通用的继承实现方式，新建个空函数，将父类的原型赋给这个空函数再生成实例赋值给子类的原型。万变不离其宗。原理都一样</span>
    <span class="comment">//增加extend方法。这是个语法糖，本质上还是调用P来实现，只不过第一个参数是调用者C</span>
    C.extend = <span class="function"><span class="keyword">function</span><span class="params">(def)</span> {</span> <span class="keyword">return</span> P(C, def); }
    <span class="comment">//下面是最关键的地方，写的有点绕。这边分为这几步</span>
    <span class="comment">//传入definition 执行 function（def）{} </span>
    <span class="comment">// 执行C.open = C</span>
    <span class="comment">// return C.open 其实就是 renturn C 返回最终的生成类</span>
    <span class="keyword">return</span> (C.open = <span class="function"><span class="keyword">function</span><span class="params">(def)</span> {</span>
      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">'function'</span>) {
        <span class="comment">// call the defining function with all the arguments you need</span>
        <span class="comment">// extensions captures the return value.</span>
        <span class="comment">//是函数的话就传入 一些属性包括子类原型，父类原型，子类构造函数，父类构造函数</span>
        def = def.call(C, proto, _super, C, _superclass);
      }

      <span class="comment">// 如果是对象，就直接混入到原型</span>
      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">'object'</span>) {
        <span class="keyword">for</span> (key <span class="keyword">in</span> def) {
          <span class="keyword">if</span> (ownProperty.call(def, key)) {
            proto[key] = def[key];
          }
        }
      }

      <span class="comment">//确保有init函数</span>
      <span class="keyword">if</span> (!(<span class="string">'init'</span> <span class="keyword">in</span> proto)) proto.init = _superclass;

      <span class="keyword">return</span> C;
    })(definition);
  }

})(<span class="string">'prototype'</span>, ({}).hasOwnProperty);
</pre></td></tr></table></figure>

<h3 id="阿拉蕾的实现方式">阿拉蕾的实现方式</h3>
<p>这是支付宝的库阿拉蕾的实现，我觉得是最不错的一种方式：<br>源地址：<a href="https://github.com/aralejs/class/blob/master/class.js" target="_blank">https://github.com/aralejs/class/blob/master/class.js</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
</pre></td><td class="code"><pre>
<span class="comment">// The base Class implementation.</span>
<span class="function"><span class="keyword">function</span> <span class="title">Class</span><span class="params">(o)</span> {</span>
  <span class="comment">//这个判断用来支持 将一个已有普通类转换成 阿拉蕾的类</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Class) && isFunction(o)) {
    <span class="comment">//原理是给这个函数增加extend，implement方法</span>
    <span class="keyword">return</span> classify(o)
  }
}
<span class="comment">//用来支持 commonjs的模块规范。</span>
module.exports = Class


<span class="comment">// Create a new Class.</span>
<span class="comment">//</span>
<span class="comment">//  var SuperPig = Class.create({</span>
<span class="comment">//    Extends: Animal,</span>
<span class="comment">//    Implements: Flyable,</span>
<span class="comment">//    initialize: function() {</span>
<span class="comment">//      SuperPig.superclass.initialize.apply(this, arguments)</span>
<span class="comment">//    },</span>
<span class="comment">//    Statics: {</span>
<span class="comment">//      COLOR: 'red'</span>
<span class="comment">//    }</span>
<span class="comment">// })</span>
<span class="comment">//</span>
<span class="comment">//</span>

<span class="comment">//用于创建一个类，</span>
<span class="comment">//第一个参数可选，可以直接创建时就指定继承的父类。</span>
<span class="comment">//第二个参数也可选，用来表明需要混入的类属性。有三个特殊的属性为Extends,Implements,Statics.分别代表要继承的父类，需要混入原型的东西，还有静态属性。</span>
Class.create = <span class="function"><span class="keyword">function</span><span class="params">(parent, properties)</span> {</span>
  <span class="comment">//创建一个类时可以不指定要继承的父类。直接传入属性对象。</span>
  <span class="keyword">if</span> (!isFunction(parent)) {
    properties = parent
    parent = <span class="literal">null</span>
  }

  properties || (properties = {})
  <span class="comment">//没有指定父类的话 就查看有没有Extends特殊属性，都没有的话就用Class作为父类</span>
  parent || (parent = properties.Extends || Class)
  properties.Extends = parent

  <span class="comment">// 子类构造函数的定义</span>
  <span class="function"><span class="keyword">function</span> <span class="title">SubClass</span><span class="params">()</span> {</span>
    <span class="comment">// 自动帮忙调用父类的构造函数</span>
    parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)

    <span class="comment">// Only call initialize in self constructor.</span>
    <span class="comment">//真正的构造函数放在initialize里面</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.constructor === SubClass && <span class="keyword">this</span>.initialize) {
      <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)
    }
  }

  <span class="comment">// Inherit class (static) properties from parent.</span>
  <span class="comment">//parent为Class就没必要混入</span>
  <span class="keyword">if</span> (parent !== Class) {
    <span class="comment">//将父类里面的属性都混入到子类里面这边主要是静态属性</span>
    mix(SubClass, parent, parent.StaticsWhiteList)
  }

  <span class="comment">// Add instance properties to the subclass.</span>
  <span class="comment">//调用implement将自定义的属性混入到子类原型里面。遇到特殊值会单独处理，真正的继承也是发生在这里面</span>
  <span class="comment">//这边把属性也都弄到了原型上，因为这边每次create或者extend都会生成一个新的SubClass。所以倒也不会发生属性公用的问题。但是总感觉不大好</span>
  implement.call(SubClass, properties)

  <span class="comment">// Make subclass extendable.</span>
  <span class="comment">//给生成的子类增加extend和implement方法，可以在类定义完后，再去继承，去混入其他属性。</span>
  <span class="keyword">return</span> classify(SubClass)
}

<span class="comment">//用于在类定义之后，往类里面添加方法。提供了之后修改类的可能。类似上面defjs实现的open函数。</span>
<span class="function"><span class="keyword">function</span> <span class="title">implement</span><span class="params">(properties)</span> {</span>
  <span class="keyword">var</span> key, value

  <span class="keyword">for</span> (key <span class="keyword">in</span> properties) {
    value = properties[key]
    <span class="comment">//发现属性是特殊的值时，调用对应的处理函数处理</span>
    <span class="keyword">if</span> (Class.Mutators.hasOwnProperty(key)) {
      Class.Mutators[key].call(<span class="keyword">this</span>, value)
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.prototype[key] = value
    }
  }
}


<span class="comment">// Create a sub Class based on `Class`.</span>
Class.extend = <span class="function"><span class="keyword">function</span><span class="params">(properties)</span> {</span>
  properties || (properties = {})
  <span class="comment">//定义继承的对象是自己</span>
  properties.Extends = <span class="keyword">this</span>
  <span class="comment">//调用Class.create实现继承的流程</span>
  <span class="keyword">return</span> Class.create(properties)
}

<span class="comment">//给一个普通的函数 增加extend和implement方法。</span>
<span class="function"><span class="keyword">function</span> <span class="title">classify</span><span class="params">(cls)</span> {</span>
  cls.extend = Class.extend
  cls.implement = implement
  <span class="keyword">return</span> cls
}


<span class="comment">// 这里定义了一些特殊的属性，阿拉蕾遍历时发现key是这里面的一个时，会调用这里面的方法处理。</span>
Class.Mutators = {
  <span class="comment">//这个定义了继承的真正操作代码。</span>
  <span class="string">'Extends'</span>: <span class="function"><span class="keyword">function</span><span class="params">(parent)</span> {</span>
    <span class="comment">//这边的this指向子类</span>
    <span class="keyword">var</span> existed = <span class="keyword">this</span>.prototype
    <span class="comment">//生成一个中介原型，就是之前我们实现的objectCreat</span>
    <span class="keyword">var</span> proto = createProto(parent.prototype)

    <span class="comment">//将子类原型有的方法混入到新的中介原型上</span>
    mix(proto, existed)

    <span class="comment">// 改变构造函数指向子类</span>
    proto.constructor = <span class="keyword">this</span>

    <span class="comment">// 改变原型 完成继承</span>
    <span class="keyword">this</span>.prototype = proto

    <span class="comment">//为子类增加superclass属性，这样可以调用父类原型的方法。</span>
    <span class="keyword">this</span>.superclass = parent.prototype
  },
  <span class="comment">//这个有点类似组合的概念，支持数组。将其他类的属性混入到子类原型上</span>
  <span class="string">'Implements'</span>: <span class="function"><span class="keyword">function</span><span class="params">(items)</span> {</span>
    isArray(items) || (items = [items])
    <span class="keyword">var</span> proto = <span class="keyword">this</span>.prototype, item

    <span class="keyword">while</span> (item = items.shift()) {
      mix(proto, item.prototype || item)
    }
  },
  <span class="comment">//传入静态属性</span>
  <span class="string">'Statics'</span>: <span class="function"><span class="keyword">function</span><span class="params">(staticProperties)</span> {</span>
    mix(<span class="keyword">this</span>, staticProperties)
  }
}


<span class="comment">// Shared empty constructor function to aid in prototype-chain creation.</span>
<span class="function"><span class="keyword">function</span> <span class="title">Ctor</span><span class="params">()</span> {</span>
}

<span class="comment">// 这个方法就是我们之前实现的objectCreat，用来使用一个中介者来处理原型的问题，当浏览器支持`__proto__`时可以直接使用。否则新建一个空函数再将父类的原型赋值给这个空函数，返回这个空函数的实例</span>
<span class="keyword">var</span> createProto = <span class="built_in">Object</span>.__proto__ ?
    <span class="function"><span class="keyword">function</span><span class="params">(proto)</span> {</span>
      <span class="keyword">return</span> { __proto__: proto }
    } :
    <span class="function"><span class="keyword">function</span><span class="params">(proto)</span> {</span>
      Ctor.prototype = proto
      <span class="keyword">return</span> <span class="keyword">new</span> Ctor()
    }


<span class="comment">// Helpers 下面都是些辅助方法，很简单就不说了</span>
<span class="comment">// ------------</span>

<span class="function"><span class="keyword">function</span> <span class="title">mix</span><span class="params">(r, s, wl)</span> {</span>
  <span class="comment">// Copy "all" properties including inherited ones.</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> s) {
    <span class="comment">//过滤掉原型链上面的属性</span>
    <span class="keyword">if</span> (s.hasOwnProperty(p)) {
      <span class="keyword">if</span> (wl && indexOf(wl, p) === -<span class="number">1</span>) <span class="keyword">continue</span>

      <span class="comment">// 在 iPhone 1 代等设备的 Safari 中，prototype 也会被枚举出来，需排除</span>
      <span class="keyword">if</span> (p !== <span class="string">'prototype'</span>) {
        r[p] = s[p]
      }
    }
  }
}


<span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString

<span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span><span class="params">(val)</span> {</span>
    <span class="keyword">return</span> toString.call(val) === <span class="string">'[object Array]'</span>
}

<span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span><span class="params">(val)</span> {</span>
  <span class="keyword">return</span> toString.call(val) === <span class="string">'[object Function]'</span>
}

<span class="keyword">var</span> indexOf = <span class="built_in">Array</span>.prototype.indexOf ?
    <span class="function"><span class="keyword">function</span><span class="params">(arr, item)</span> {</span>
      <span class="keyword">return</span> arr.indexOf(item)
    } :
    <span class="function"><span class="keyword">function</span><span class="params">(arr, item)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) {
        <span class="keyword">if</span> (arr[i] === item) {
          <span class="keyword">return</span> i
        }
      }
      <span class="keyword">return</span> -<span class="number">1</span>
    }
</pre></td></tr></table></figure>

<p>万变不离其宗，本质上还是我们之前的继承方式，只是在上面再封装一层，更加清晰，明白了。<br>还有很多很多的实现，这边就不一一列举了。</p>
<h2 id="未来科技的oo实现">未来科技的oo实现</h2>
<p>其实 es6已经开始重视emcsript的oo实现了。不过还没定案，就算定案了，也不知道嘛时候javascript会实现。再加上一大堆浏览器的跟进。不知道什么时候才能用的上。不过了解下最新的规范还是很有必要的。</p>
<p>目前nodejs里面已经实现了 inherite方法用来实现类继承，类似我们上面的那种实现。</p>
<p>而es6（harmony）实现了class关键字用来创建类，并且具有类该有的一系列方法。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>class Monster {
  <span class="comment">// The contextual keyword "constructor" followed by an argument</span>
  <span class="comment">// list and a body defines the body of the class’s constructor</span>
  <span class="comment">// function. public and private declarations in the constructor</span>
  <span class="comment">// declare and initialize per-instance properties. Assignments</span>
  <span class="comment">// such as "this.foo = bar;" also set public properties.</span>
  constructor(name, health) {
    <span class="keyword">public</span> name = name;
    <span class="keyword">private</span> health = health;
  }
 
  <span class="comment">// An identifier followed by an argument list and body defines a</span>
  <span class="comment">// method. A “method” here is simply a function property on some</span>
  <span class="comment">// object.</span>
  attack(target) {
    log(<span class="string">'The monster attacks '</span> + target);
  }
 
  <span class="comment">// The contextual keyword "get" followed by an identifier and</span>
  <span class="comment">// a curly body defines a getter in the same way that "get"</span>
  <span class="comment">// defines one in an object literal.</span>
  <span class="keyword">get</span> isAlive() {
    <span class="keyword">return</span> <span class="keyword">private</span>(<span class="keyword">this</span>).health &gt; 0;
  }
 
  <span class="comment">// Likewise, "set" can be used to define setters.</span>
  <span class="keyword">set</span> health(<span class="keyword">value</span>) {
    <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Health must be non-negative.'</span>)
    }
    <span class="keyword">private</span>(<span class="keyword">this</span>).health = <span class="keyword">value</span>
  }
 
  <span class="comment">// After a "public" modifier,</span>
  <span class="comment">// an identifier optionally followed by "=" and an expression</span>
  <span class="comment">// declares a prototype property and initializes it to the value</span>
  <span class="comment">// of that expression. </span>
  <span class="keyword">public</span> numAttacks = <span class="number">0</span>;
 
  <span class="comment">// After a "public" modifier,</span>
  <span class="comment">// the keyword "const" followed by an identifier and an</span>
  <span class="comment">// initializer declares a constant prototype property.</span>
  <span class="keyword">public</span> <span class="keyword">const</span> attackMessage = <span class="string">'The monster hits you!'</span>;
}
</pre></td></tr></table></figure>

<p>可以看到具有了传统oo里面的大部分关键字，私有属性也得到了支持。</p>
<p>继承也很容易：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>}
<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> {</span>}
 
<span class="comment">//Here, Derived.prototype will inherit from Base.prototype.</span>
 
let <span class="keyword">parent</span> = {};
<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">prototype</span> <span class="title">parent</span> {</span>}
</pre></td></tr></table></figure>

<p>原文在这里：<a href="http://h3manth.com/content/classes-javascript-es6" target="_blank">http://h3manth.com/content/classes-javascript-es6</a></p>
<h2 id="结语">结语</h2>
<p>虽然es6已经实现了正规的class关键字。不过等到真正能用上也不知道是何年马月了。不过规范提供了方向，在es6还没出来之前，n多大神前仆后继实现了自己的class方式，分析源码可以学到的还是很多，仅仅一个类的实现就可以抠出这么多的类容，程序员还是应该多探索，不能只停留在表面。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/javascript/">javascript</a><a href="/tags/class/">class</a><a href="/tags/oo/">oo</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/javascript/">javascript</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://purplebamboo.github.com/2014/07/13/javascript-oo-class/" data-title="javascript oo实现 | blog of purplebamboo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/09/27/javascript-syntax-tree/" title="javascript语法树">
  <strong>PREVIOUS:</strong><br/>
  <span>
  javascript语法树</span>
</a>
</div>


<div class="next">
<a href="/2014/06/14/use-javascript-async-run-javascript/"  title="javascript动态插入代码并执行">
 <strong>NEXT:</strong><br/> 
 <span>javascript动态插入代码并执行
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始时代最简单的oo实现"><span class="toc-number">1.</span> <span class="toc-text">原始时代最简单的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#石器时代的oo实现"><span class="toc-number">2.</span> <span class="toc-text">石器时代的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工业时代的oo实现"><span class="toc-number">3.</span> <span class="toc-text">工业时代的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现代科技时代的oo实现"><span class="toc-number">4.</span> <span class="toc-text">现代科技时代的oo实现</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#John_Resig的实现方式"><span class="toc-number">4.1.</span> <span class="toc-text">John Resig的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P-js的实现"><span class="toc-number">4.2.</span> <span class="toc-text">P.js的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阿拉蕾的实现方式"><span class="toc-number">4.3.</span> <span class="toc-text">阿拉蕾的实现方式</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#未来科技的oo实现"><span class="toc-number">5.</span> <span class="toc-text">未来科技的oo实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">6.</span> <span class="toc-text">结语</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/angularjs记录/" title="angularjs记录">angularjs记录<sup>9</sup></a></li>
		
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/categories/iconfont技术/" title="iconfont技术">iconfont技术<sup>2</sup></a></li>
		
			<li><a href="/categories/javascript/" title="javascript">javascript<sup>18</sup></a></li>
		
			<li><a href="/categories/javascript/nodejs/" title="nodejs">nodejs<sup>2</sup></a></li>
		
			<li><a href="/categories/从零单排/" title="从零单排">从零单排<sup>1</sup></a></li>
		
			<li><a href="/categories/各种知识点记录/" title="各种知识点记录">各种知识点记录<sup>1</sup></a></li>
		
			<li><a href="/categories/javascript/源码分析/" title="源码分析">源码分析<sup>7</sup></a></li>
		
			<li><a href="/categories/系统环境/" title="系统环境">系统环境<sup>1</sup></a></li>
		
			<li><a href="/categories/angularjs记录/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Filters/" title="Filters">Filters<sup>1</sup></a></li>
		
			<li><a href="/tags/analyze/" title="analyze">analyze<sup>1</sup></a></li>
		
			<li><a href="/tags/angular/" title="angular">angular<sup>2</sup></a></li>
		
			<li><a href="/tags/angularjs/" title="angularjs">angularjs<sup>7</sup></a></li>
		
			<li><a href="/tags/ast/" title="ast">ast<sup>1</sup></a></li>
		
			<li><a href="/tags/async/" title="async">async<sup>1</sup></a></li>
		
			<li><a href="/tags/border-shadow/" title="border-shadow">border-shadow<sup>1</sup></a></li>
		
			<li><a href="/tags/chunked/" title="chunked">chunked<sup>1</sup></a></li>
		
			<li><a href="/tags/class/" title="class">class<sup>1</sup></a></li>
		
			<li><a href="/tags/co/" title="co">co<sup>2</sup></a></li>
		
			<li><a href="/tags/comet/" title="comet">comet<sup>1</sup></a></li>
		
			<li><a href="/tags/controllers/" title="controllers">controllers<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/generator/" title="generator">generator<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
		
			<li><a href="/tags/html/" title="html">html<sup>1</sup></a></li>
		
			<li><a href="/tags/iconfont/" title="iconfont">iconfont<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>15</sup></a></li>
		
			<li><a href="/tags/koa/" title="koa">koa<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://ued.taobao.com/" target="_blank">淘宝UED</a> </li>            <li><a href="http://www.aliued.com/" target="_blank">Alibaba国际站UED</a> </li>            <li><a href="http://china.aliued.com/" target="_blank">Alibaba中文站UED</a> </li>            <li><a href="http://ued.alipay.com/" target="_blank"> 支付宝UED</a> </li>            <li><a href="http://ued.tmall.com/" target="_blank">天猫UED</a> </li><li><a href="http://ur.alibaba-inc.com">阿里用户体验中心</a> </li>	 <li><a href="http://www.uisdc.com" target="_blank">优秀网页设计</a> </li>
      
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://purplebamboo.github.com" target="_blank" title="purplebamboo">purplebamboo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"cherishpeace"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script type="text/javascript">
  $(function(){
    window.onscroll = function(){
      //console.log($(document).scrollTop()+"px")
      $('.background-container .bg-dy2').css('backgroundPosition','0 '+$(document).scrollTop()+"px");
    }

  })
</script>
<div class="background-container">
  <div class="bg-dy1">

  </div>
  <div class="bg-dy2">

  </div>

</div

  </body>
</html>
